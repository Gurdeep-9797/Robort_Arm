# ESP32 Robot Canvas - Integration Explanation

## What Was Done

Combined `app.js` and `simulator.js` into **ONE** unified file: `robot_canvas.js`

## Architecture Overview

```
┌─────────────────────────────────────────────────────┐
│              LAPTOP / BROWSER                       │
│  ┌──────────────────────────────────────────────┐  │
│  │  robot_canvas.js (THIS FILE)                 │  │
│  │                                               │  │
│  │  ┌────────────────────────────────────────┐  │  │
│  │  │ RobotSimulator (Three.js)              │  │  │
│  │  │ - Renders 3D robot locally             │  │  │
│  │  │ - Validates motion before sending      │  │  │
│  │  │ - Instant visual feedback (no latency) │  │  │
│  │  └────────────────────────────────────────┘  │  │
│  │                    ↓                          │  │
│  │  ┌────────────────────────────────────────┐  │  │
│  │  │ ESP32API                               │  │  │
│  │  │ - Sends HIGH-LEVEL commands only       │  │  │
│  │  │ - fetch() for commands                 │  │  │
│  │  │ - WebSocket for telemetry              │  │  │
│  │  └────────────────────────────────────────┘  │  │
│  └──────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────┘
                         ↓ ↑
              WiFi (commands / telemetry)
                         ↓ ↑
┌─────────────────────────────────────────────────────┐
│              ESP32 MICROCONTROLLER                  │
│  - Receives: Joint targets, cartesian waypoints    │
│  - Executes: Physical motion with safety checks    │
│  - Returns: Actual positions via telemetry         │
└─────────────────────────────────────────────────────┘
```

## Why Simulation is Local

**Problem:** If simulator runs on ESP32, every frame requires network round-trip (50-100ms latency)

**Solution:** Simulator runs entirely in browser
- **Instant feedback** when user moves sliders (0ms latency)
- **Validates motion** before sending to ESP32
- **Previews trajectories** without touching hardware
- **Displays digital twin** showing real vs simulated pose

## How ESP32 is Isolated

**ESP32 receives ONLY:**
- ✅ Target joint positions (e.g., "Move Joint 1 to 45°")
- ✅ Target cartesian coordinates (e.g., "Move TCP to X:300, Y:0, Z:250")
- ✅ Motion parameters (velocity, acceleration)

**ESP32 does NOT receive:**
- ❌ Individual animation frames
- ❌ Raw encoder values from simulation
- ❌ High-frequency joint streaming (>10Hz)
- ❌ STL model data

**Result:** ESP32 remains authoritative for physical robot safety

## Why This Avoids Latency

| Operation | Where It Runs | Latency |
|-----------|---------------|---------|
| Move slider | Browser → Simulator | 0ms (immediate) |
| Validate motion | Browser (local IK) | <10ms |
| Send command | Browser → ESP32 | 50-100ms (WiFi) |
| Execute motion | ESP32 → Servos | Real-time (1kHz) |
| Telemetry back | ESP32 → Browser | 50-100ms (WiFi) |
| Update overlay | Browser (received data) | 0ms |

**Key Point:** User sees instant feedback in simulator, then ESP32 executes validated motion independently.

---

## HTML Integration

**Minimal change needed in `index.html`:**

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Robot Arm Control</title>
    <link rel="stylesheet" href="style.css">
    
    <!-- Three.js (required for simulator) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
</head>
<body>
    <!-- Your existing HTML structure -->
    <div id="simulation-container"></div>
    
    <!-- SINGLE JS FILE -->
    <script src="robot_canvas.js"></script>
</body>
</html>
```

**That's it!** No need for separate `app.js` or `simulator.js`

---

## File Structure in ESP32 `/data` Folder

```
/data
├── index.html          (your UI structure)
├── style.css           (your styling)
└── robot_canvas.js     (THIS FILE - replaces app.js + simulator.js)
```

---

## Key Features Preserved

✅ **All original functionality maintained:**
- WebSocket telemetry
- Joint control sliders
- Cartesian moves
- Plane definition
- STL loading
- Emergency stop
- Configuration updates
- Session export

✅ **New benefits:**
- Single file = easier deployment
- Clear separation of concerns
- No code duplication
- Better performance (local sim)

---

## Usage Example

**1. User moves slider:**
```javascript
slider.oninput = function() {
    // STEP 1: Update local simulator (instant)
    simulator.updateRobotPose([...newPositions], false);
    
    // Visual feedback happens immediately (0ms)
}

slider.onchange = function() {
    // STEP 2: Send to ESP32 (when user releases)
    ESP32API.moveJoint(joint, position);
    
    // Hardware moves after command received
}
```

**2. ESP32 sends telemetry back:**
```javascript
ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    
    // Update "real robot" overlay with actual positions
    simulator.updateRobotPose(data.joints, true);
    
    // Calculate deviation between simulated and real
    simulator.updateDeviationDisplay();
}
```

---

## Safety Guarantees

1. **Simulator crashes don't affect ESP32** - they run independently
2. **Network loss doesn't break simulation** - continues running locally
3. **ESP32 remains authoritative** - it validates and executes all commands
4. **No shared control loops** - simulation and hardware are decoupled

---

## Debugging

**Open browser console and access:**

```javascript
// View global state
window.RobotDebug.state

// Access API methods
window.RobotDebug.api.fetchStatus()

// Access simulator
window.RobotDebug.simulator()
```

---

## Production Deployment

**To deploy to ESP32:**

1. Save file as `/data/robot_canvas.js`
2. Update `index.html` to include single script tag
3. Upload filesystem to ESP32: `pio run --target uploadfs`
4. Open `http://<ESP32-IP>` in browser
5. Simulator loads and connects automatically

**No server-side changes needed** - ESP32 firmware remains unchanged.

---

## Performance Characteristics

- **Simulator FPS:** 60fps (runs in requestAnimationFrame)
- **Telemetry rate:** 2Hz (configurable)
- **Command latency:** ~50-100ms over WiFi
- **UI responsiveness:** Instant (0ms for local updates)
- **Memory usage:** ~10MB browser, 0 bytes ESP32 (no sim on chip)

---

This architecture follows the **RoboDK model**: sophisticated simulation and planning on PC, simple command execution on embedded controller.